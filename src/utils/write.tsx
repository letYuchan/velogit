import React from 'react';
import { toast } from 'react-toastify';

export const getTodayDate = (): string => {
    const today = new Date();
    const year = today.getFullYear();
    const month = String(today.getMonth() + 1).padStart(2, '0');
    const day = String(today.getDate()).padStart(2, '0');
    return `${year}-${month}-${day}`;
};

export const getFullDateTime = () => {
    return new Date().toISOString(); // ex: '2025-07-20T23:45:13.123Z'
};

export const insertMarkdownSyntax = (
    textarea: HTMLTextAreaElement,
    name: string,
    insert: string,
    marker: string,
    afterApply?: (newValue: string) => void,
) => {
    const { selectionStart, selectionEnd, value } = textarea;
    const before = value.slice(0, selectionStart);
    const after = value.slice(selectionEnd);
    const selectedText = value.substring(selectionStart, selectionEnd);

    let newValue = '';
    let newSelectionStart = selectionStart;
    let newSelectionEnd = selectionEnd;

    const isInline = ['**', '_', '~~'].includes(marker);
    const isBlock = marker === '```';

    if (isInline) {
        const isWrapped = selectedText.startsWith(marker) && selectedText.endsWith(marker);
        if (isWrapped) {
            const unwrapped = selectedText.slice(
                marker.length,
                selectedText.length - marker.length,
            );
            newValue = before + unwrapped + after;
            newSelectionEnd = newSelectionStart + unwrapped.length;
        } else if (selectedText.length > 0) {
            newValue = before + marker + selectedText + marker + after;
            newSelectionEnd = newSelectionStart + selectedText.length + 2 * marker.length;
        } else {
            const defaultText = insert.split(marker).join('');
            newValue = before + marker + defaultText + marker + after;
            newSelectionStart += marker.length;
            newSelectionEnd = newSelectionStart + defaultText.length;
        }
    } else if (isBlock) {
        const selectedIsCodeBlock = /^```[a-z]*\n[\s\S]*?\n```$/.test(selectedText);
        if (selectedIsCodeBlock) {
            const unwrapped = selectedText.replace(/^```[a-z]*\n/, '').replace(/\n```$/, '');
            newValue = before + unwrapped + after;
            newSelectionEnd = newSelectionStart + unwrapped.length;
        } else {
            newValue = before + insert + after;
            const offset = insert.indexOf('code goes here');
            newSelectionStart = before.length + (offset >= 0 ? offset : 0);
            newSelectionEnd =
                offset >= 0 ? newSelectionStart + 'code goes here'.length : newSelectionStart;
        }
    } else if (name === 'dash') {
        newValue = before + '---\n' + after;
        newSelectionStart = newSelectionEnd = before.length + 4;
    } else if (marker === 'link') {
        const url = prompt('Enter the URL:', '');
        if (url === null) return;
        newValue = before + `[text](${url})` + after;
        newSelectionStart = before.length + 1;
        newSelectionEnd = newSelectionStart + 4;
    } else if (marker === 'image-md') {
        const url = prompt('Enter image URL:', '/velogit/images/');
        if (url === null) return;
        newValue = before + `![alt text](${url})` + after;
        newSelectionStart = before.length + 2;
        newSelectionEnd = newSelectionStart + 8;
    } else if (marker === 'image-html') {
        const maxImages = 4;
        const urls: string[] = [];
        for (let i = 0; i < maxImages; i++) {
            const u = prompt(`Enter image URL ${i + 1} (Cancel to stop):`, '/velogit/images/');
            if (!u) break;
            urls.push(u);
        }
        if (urls.length === 0) return;

        const imgTags = urls
            .map(
                u =>
                    `<img src="${u}" width="300" height="200" alt="image" style="object-fit: cover;" />`,
            )
            .join('');

        const layout =
            urls.length === 1
                ? imgTags
                : urls.length === 3
                  ? `<div style="display:grid;grid-template-columns:repeat(2,1fr);gap:2px;">
               <img src="${urls[0]}" style="width:100%;object-fit:cover;" />
               <img src="${urls[1]}" style="width:100%;object-fit:cover;" />
               <img src="${urls[2]}" style="width:100%;height:300px;object-fit:cover;grid-column:span 2;" />
             </div>`
                  : `<div style="display:grid;grid-template-columns:repeat(${Math.min(urls.length, 2)},1fr);gap:2px;">
               ${imgTags}
             </div>`;

        newValue = before + layout + after;
        newSelectionStart = before.length + layout.indexOf('alt="image"') + 5;
        newSelectionEnd = newSelectionStart + 5;
    } else if (marker === 'video') {
        const url = prompt('Enter video URL:', '/velogit/videos/');
        if (url === null) return;
        const html = `<video src="${url}" width="720" height="480" controls></video>`;
        newValue = before + html + after;
        newSelectionStart = before.length + html.indexOf(url);
        newSelectionEnd = newSelectionStart + url.length;
    } else if (marker === '<kbd>') {
        newValue = before + `<kbd>text</kbd>` + after;
        newSelectionStart = before.length + 5;
        newSelectionEnd = newSelectionStart + 4;
    } else if (marker === '<mark>') {
        newValue = before + `<mark>text</mark>` + after;
        newSelectionStart = before.length + 6;
        newSelectionEnd = newSelectionStart + 4;
    } else if (marker === 'details') {
        newValue = before + insert + after;
        const summaryIndex = insert.indexOf('Summary');
        newSelectionStart = before.length + (summaryIndex >= 0 ? summaryIndex : 0);
        newSelectionEnd =
            summaryIndex >= 0 ? newSelectionStart + 'Summary'.length : newSelectionStart;
    } else if (marker === 'file') {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '*/*';
        input.onchange = () => {
            const file = input.files?.[0];
            if (!file) return;

            const sub = prompt('Subfolder (optional):', 'your_subDirectory_name');
            const cleanSub = (sub || '').trim().replace(/^\/+|\/+$/g, '');
            const fileName = file.name;
            const encoded = encodeURIComponent(fileName);
            const base = '/velogit/uploads';
            const filePath = cleanSub ? `${base}/${cleanSub}/${encoded}` : `${base}/${encoded}`;
            const sizeMB = (file.size / (1024 * 1024)).toFixed(1);
            const ext = fileName.split('.').pop()?.toLowerCase();
            const iconMap: Record<string, string> = {
                pdf: 'üìÑ',
                doc: 'üìù',
                docx: 'üìù',
                xls: 'üìä',
                xlsx: 'üìä',
                ppt: 'üìΩÔ∏è',
                pptx: 'üìΩÔ∏è',
                png: 'üñºÔ∏è',
                jpg: 'üñºÔ∏è',
                jpeg: 'üñºÔ∏è',
                gif: 'üñºÔ∏è',
                zip: 'üóúÔ∏è',
                mp4: 'üéûÔ∏è',
                mp3: 'üéµ',
            };
            const icon = iconMap[ext ?? ''] ?? 'üìé';

            const markdown = `[${icon} ${fileName} (${sizeMB}MB)](${filePath})`;
            const next = before + markdown + after;

            textarea.value = next;
            textarea.selectionStart = textarea.selectionEnd = before.length + markdown.length;
            textarea.focus();
            textarea.dispatchEvent(new Event('input', { bubbles: true }));
            afterApply?.(next);
        };
        input.click();
        return;
    } else if (marker === 'table') {
        const colInput = prompt('Enter number of columns:', '3');
        const rowInput = prompt('Enter number of rows:', '3');
        const cols = Math.max(parseInt(colInput || '0'), 1);
        const rows = Math.max(parseInt(rowInput || '0'), 1);
        if (isNaN(cols) || isNaN(rows)) return;

        const headerRow = Array(cols)
            .fill('')
            .map((_, i) => `Header ${i + 1}`)
            .join(' | ');
        const separator = Array(cols).fill('---').join(' | ');
        const dataRows = Array(rows)
            .fill('')
            .map(() => Array(cols).fill('Cell').join(' | '));
        const tableMarkdown =
            `| ${headerRow} |\n| ${separator} |\n` + dataRows.map(r => `| ${r} |`).join('\n');

        newValue = before + tableMarkdown + '\n' + after;
        newSelectionStart = before.length;
        newSelectionEnd = before.length + tableMarkdown.length;
    } else {
        const lines = value.split('\n');
        const cursorLineIndex = value.substring(0, selectionStart).split('\n').length - 1;
        const line = lines[cursorLineIndex];
        const isAlready = marker && line.startsWith(marker);
        lines[cursorLineIndex] = isAlready ? line.replace(marker, '') : marker + line;
        newValue = lines.join('\n');

        const delta = marker ? (isAlready ? -marker.length : marker.length) : 0;
        newSelectionStart = selectionStart + delta;
        newSelectionEnd = selectionEnd + delta;
    }

    textarea.value = newValue;
    textarea.selectionStart = newSelectionStart;
    textarea.selectionEnd = newSelectionEnd;
    textarea.focus();
    textarea.dispatchEvent(new Event('input', { bubbles: true }));
    afterApply?.(newValue);
};

export const copyCorrectedTextToClipboard = async (correctedText: string, lang: 'Ko' | 'Eng') => {
    try {
        await navigator.clipboard.writeText(correctedText);
        if (lang === 'Ko') {
            toast.success('ÍµêÏ†ïÎêú ÌÖçÏä§Ìä∏Í∞Ä Î≥µÏÇ¨ÎêòÏóàÏäµÎãàÎã§!');
        }

        if (lang === 'Eng') {
            toast.success('Success to copy text!');
        }

        // eslint-disable-next-line @typescript-eslint/no-unused-vars
    } catch (err) {
        if (lang === 'Ko') {
            toast.error('ÍµêÏ†ïÎêú ÌÖçÏä§Ìä∏Î•º Î≥µÏÇ¨ÌïòÎäîÎç∞ Ïã§Ìå®ÌñàÏäµÎãàÎã§. Ïû†Ïãú ÌõÑ Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî.');
        }

        if (lang === 'Eng') {
            toast.error('Failed to copy text. Please try again later.');
        }
    }
};

export const getHighlightedFragments = <T,>(
    text: string,
    items: T[] | undefined,
    focusIndex: number,
    map: MapToHighlight<T>,
    classes: Classes = {},
): React.ReactNode[] => {
    if (!text || !items?.length) return [text];

    const baseCls =
        classes.base ??
        'rounded bg-red-200 px-0.5 text-red-800 underline decoration-red-400 decoration-2';
    const focusCls =
        classes.focus ??
        'rounded bg-red-300 px-0.5 font-bold text-red-900 underline decoration-red-600 decoration-2';

    const mapped = [...items]
        .map(map)
        .filter(m => m && typeof m.offset === 'number' && typeof m.length === 'number')
        .sort((a, b) => a.offset - b.offset);

    const out: React.ReactNode[] = [];
    let last = 0;

    mapped.forEach((m, i) => {
        const { offset, length, tooltip } = m;

        const start = Math.max(0, Math.min(text.length, offset));
        const end = Math.max(start, Math.min(text.length, offset + length));

        if (start > last) out.push(text.slice(last, start));

        const slice = text.slice(start, end);
        const isFocus = i === focusIndex;

        out.push(
            <mark
                key={`hl-${i}-${start}-${end}`}
                className={isFocus ? focusCls : baseCls}
                title={tooltip}
            >
                {slice || '‚àÖ'}
            </mark>,
        );

        last = end;
    });

    if (last < text.length) out.push(text.slice(last));
    return out;
};

export const mapLanguageToolMatch: MapToHighlight<Match> = m => ({
    offset: m.offset,
    length: m.length,
    tooltip: m.message,
});

export const mapKoChange: MapToHighlight<KoChange> = c => {
    const op = !c.from && c.to ? 'INSERT' : c.from && !c.to ? 'DELETE' : 'REPLACE';
    return {
        offset: c.offset,
        length: c.length,
        tooltip: `${op} ‚Äî "${c.from || '‚àÖ'}" ‚Üí "${c.to || '‚àÖ'}"`,
    };
};

export const handlePasteImageUrl = (e: React.ClipboardEvent<HTMLTextAreaElement>) => {
    const ta = e.currentTarget;
    const plain = e.clipboardData.getData('text/plain')?.trim();
    if (!plain) return false;

    const isImgUrl = /^https?:\/\/[^\s]+?\.(png|jpe?g|gif|webp|svg)(\?[^\s]*)?$/i.test(plain);
    if (!isImgUrl) return false;

    e.preventDefault();

    const asHtml = confirm('Image URL detected.\nOK = HTML <img>, Cancel = Markdown ![]()');

    const snippet = asHtml ? `<img src="${plain}" alt="image" height="300px" width="200px" />` : `![image](${plain})`;

    insertAtCursor(ta, snippet);
    return true;
};

const insertAtCursor = (ta: HTMLTextAreaElement, text: string) => {
    const { selectionStart, selectionEnd, value } = ta;
    const next = value.slice(0, selectionStart) + text + value.slice(selectionEnd);
    ta.value = next;
    const pos = selectionStart + text.length;
    ta.selectionStart = ta.selectionEnd = pos;
    ta.focus();
    ta.dispatchEvent(new Event('input', { bubbles: true }));
};

/*
Ïú†Ìã∏Î¶¨Ìã∞ Î™®Ïùå (Markdown/Clipboard/TOC-Highlight Helpers)

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
1) getTodayDate()
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
- Í∏∞Îä•: Ïò§Îäò ÎÇ†ÏßúÎ•º 'YYYY-MM-DD' Ìè¨Îß∑ Î¨∏ÏûêÏó¥Î°ú Î∞òÌôò.
- ÏûÖÎ†•: ÏóÜÏùå
- Ï∂úÎ†•: string (Ïòà: '2025-08-13')
- ÎπÑÍ≥†: Î°úÏª¨ ÌÉÄÏûÑÏ°¥ Í∏∞Ï§Ä.

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
2) getFullDateTime()
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
- Í∏∞Îä•: ÌòÑÏû¨ ÏãúÍ∞ÅÏùÑ ISO 8601 Î¨∏ÏûêÏó¥Î°ú Î∞òÌôò.
- ÏûÖÎ†•: ÏóÜÏùå
- Ï∂úÎ†•: string (Ïòà: '2025-07-20T23:45:13.123Z')
- ÎπÑÍ≥†: Ìï≠ÏÉÅ UTC(Z) Ìè¨Îß∑.

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
3) insertMarkdownSyntax(textarea, name, insert, marker, afterApply?)
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
- Í∏∞Îä•: textareaÏùò ÌòÑÏû¨ ÏÑ†ÌÉù ÏòÅÏó≠/Ïª§ÏÑú ÏúÑÏπòÎ•º Í∏∞Ï§ÄÏúºÎ°ú ÎßàÌÅ¨Îã§Ïö¥/HTML Ï°∞Í∞ÅÏùÑ ÏÇΩÏûÖÌïòÍ±∞ÎÇò ÌÜ†Í∏Ä.
- Í≥µÌÜµ ÏûÖÎ†•:
  - textarea: HTMLTextAreaElement (ÎåÄÏÉÅ ÏóêÎîîÌÑ∞)
  - name: string        ‚Üí ÏùºÎ∂Ä Ìà¥Î∞î Î≤ÑÌäº ÏãùÎ≥Ñ(Ïòà: 'dash')
  - insert: string      ‚Üí Î∏îÎ°ù ÏÇΩÏûÖÏö© ÌÖúÌîåÎ¶ø(Ïòà: ÏΩîÎìúÎ∏îÎ°ù/ÎîîÌÖåÏùºÏä§ Îì±)
  - marker: string      ‚Üí ÌÜ†Í∏Ä/ÏÇΩÏûÖ ÌëúÏãúÏûê(Ïòà: '**', '_', '~~', '```', 'link', 'image-md', 'image-html', 'video', '<kbd>', '<mark>', 'details', 'file', 'table' ...)
  - afterApply?: (newValue: string) => void ‚Üí ÏÇΩÏûÖ ÌõÑ Ï†ÑÏ≤¥ ÌÖçÏä§Ìä∏Î•º ÏΩúÎ∞±ÏúºÎ°ú Ï†ÑÎã¨
- Ï£ºÏöî Î∂ÑÍ∏∞:
  ‚ë† Ïù∏ÎùºÏù∏ ÌÜ†Í∏Ä(**, _, ~~)
    - ÏÑ†ÌÉù ÏòÅÏó≠Ïóê ÎèôÏùº markerÍ∞Ä Í∞êÏã∏Ï†∏ ÏûàÏúºÎ©¥ Ìï¥Ï†ú, ÏïÑÎãàÎ©¥ Í∞êÏã∏Í∏∞
    - ÏÑ†ÌÉùÏù¥ ÏóÜÏúºÎ©¥ Í∏∞Î≥∏ ÌÖçÏä§Ìä∏Î•º ÏÇΩÏûÖ ÌõÑ ÏÑ†ÌÉù ÏòÅÏó≠ ÏßÄÏ†ï
  ‚ë° ÏΩîÎìúÎ∏îÎ°ù( ``` )
    - ÏÑ†ÌÉù ÏòÅÏó≠Ïù¥ ÏôÑÏ†ÑÌïú ÏΩîÎìúÎ∏îÎ°ùÏù¥Î©¥ Ïñ∏Îû©, ÏïÑÎãàÎ©¥ insert ÌÖúÌîåÎ¶ø ÏÇΩÏûÖ
    - 'code goes here' Ìè¨Ïª§Ïä§ ÏúÑÏπò ÏÑ†ÌÉù
  ‚ë¢ ÏàòÌèâÏÑ†(dash)
    - '---\n' ÏÇΩÏûÖ
  ‚ë£ ÎßÅÌÅ¨(link)
    - promptÎ°ú URL ÏûÖÎ†• Î∞õÏïÑ `[text](url)`ÏÇΩÏûÖ, 'text' Î∂ÄÎ∂Ñ ÏÑ†ÌÉù
  ‚ë§ Ïù¥ÎØ∏ÏßÄ(Markdown: image-md)
    - promptÎ°ú URL ÏûÖÎ†• Î∞õÏïÑ `![alt text](url)` ÏÇΩÏûÖ, 'alt text' ÏÑ†ÌÉù
  ‚ë• Ïù¥ÎØ∏ÏßÄ(HTML: image-html)
    - ÏµúÎåÄ 4Í∞úÍπåÏßÄ URL ÏûÖÎ†•Î∞õÏïÑ 1/2/3/4Ïû• Î†àÏù¥ÏïÑÏõÉ ÏûêÎèô Íµ¨ÏÑ±(Grid)
  ‚ë¶ ÎπÑÎîîÏò§(video)
    - `<video src="..." width="720" height="480" controls></video>` ÏÇΩÏûÖ
    - Ïª§ÏÑúÍ∞Ä URL Î∂ÄÎ∂ÑÏùÑ Í∞ÄÎ¶¨ÌÇ§ÎèÑÎ°ù ÏÑ†ÌÉù
  ‚ëß ÌÇ§Î≥¥Îìú/ÎßàÌÅ¨ ÌÉúÍ∑∏(<kbd>, <mark>)
    - Í∞ÅÍ∞Å `<kbd>text</kbd>`, `<mark>text</mark>` ÏÇΩÏûÖ ÌõÑ 'text' ÏÑ†ÌÉù
  ‚ë® details
    - Ï†ÑÎã¨Îêú insert(Ïòà: `<details><summary>Summary</summary>...</details>`) ÏÇΩÏûÖ
    - 'Summary' ÌÖçÏä§Ìä∏Ïóê Ïª§ÏÑú ÎßûÏ∂§
  ‚ë© ÌååÏùº(file)
    - ÌååÏùº ÏÑ†ÌÉù inputÏùÑ Ïó¥Í≥†, ÏÑ†ÌÉù ÌååÏùº Î©îÌÉÄ(ÏïÑÏù¥ÏΩò/ÌÅ¨Í∏∞)Î°ú ÎßàÌÅ¨Îã§Ïö¥ ÎßÅÌÅ¨ ÏÉùÏÑ±
    - ÏÑúÎ∏åÌè¥Îçî ÏûÖÎ†• ÏßÄÏõê: 'test', 'test/more/deep' Îì± Îã§Îã®Í≥Ñ Í∞ÄÎä•
      - Í≤ΩÎ°ú: /velogit/uploads/[subpath]/encodedFileName
    - ÏòàÏãú ÎßàÌÅ¨Îã§Ïö¥: `[üìÑ sample.pdf (1.2MB)](/velogit/uploads/docs/sample.pdf)`
  ‚ë™ Ìëú(table)
    - promptÎ°ú Ìñâ/Ïó¥ Ïàò ÏûÖÎ†• ‚Üí GFM ÌÖåÏù¥Î∏î ÎßàÌÅ¨Îã§Ïö¥ ÏûêÎèô ÏÉùÏÑ±
  ‚ë´ Í∏∞Î≥∏(Í∏∞ÌÉÄ marker)
    - ÌòÑÏû¨ Ï§ÑÏóê marker ÌÜ†Í∏Ä(Ìï¥Îãπ Ï§Ñ ÏïûÏóê prefix Î∂ôÏòÄÎã§/Îóå)
- Í≥µÌÜµ Ï≤òÎ¶¨:
  - ÏÇΩÏûÖ ÌõÑ textarea value/selection Í∞±Ïã†, focus, input Ïù¥Î≤§Ìä∏ dispatchÎ°ú React onChange Ïú†ÎèÑ
  - afterApply ÏΩúÎ∞±ÏúºÎ°ú ÏµúÏã† Î¨∏ÏûêÏó¥ Ï†ÑÎã¨
- Ï£ºÏùò:
  - prompt Í∏∞Î∞ò UXÎäî Î∏åÎùºÏö∞Ï†Ä ÌôòÍ≤Ω Ï†ÑÏ†ú
  - ÏóÖÎ°úÎìú/Ï†ïÏ†Å Ìò∏Ïä§ÌåÖ Í≤ΩÎ°ú(/velogit/uploads/...)Îäî Î∞∞Ìè¨ ÌôòÍ≤ΩÏóê ÎßûÍ≤å Í¥ÄÎ¶¨ ÌïÑÏöî
  - ÏÑúÎ∏åÌè¥ÎçîÎäî ÏïûÎí§ Ïä¨ÎûòÏãú Ï†ïÎ¶¨(Ï§ëÍ∞Ñ Ïä¨ÎûòÏãúÎäî Ïú†ÏßÄ)

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
4) copyCorrectedTextToClipboard(correctedText, lang)
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
- Í∏∞Îä•: ÍµêÏ†ïÎêú ÌÖçÏä§Ìä∏Î•º ÌÅ¥Î¶ΩÎ≥¥ÎìúÏóê Î≥µÏÇ¨ÌïòÍ≥†, Ïñ∏Ïñ¥Î≥Ñ ÌÜ†Ïä§Ìä∏ Î©îÏãúÏßÄ ÌëúÏãú.
- ÏûÖÎ†•:
  - correctedText: string
  - lang: 'Ko' | 'Eng'
- Ï∂úÎ†•: Promise<void>
- ÎèôÏûë:
  - ÏÑ±Í≥µ Ïãú: Ko ‚Üí 'ÍµêÏ†ïÎêú ÌÖçÏä§Ìä∏Í∞Ä Î≥µÏÇ¨ÎêòÏóàÏäµÎãàÎã§!', Eng ‚Üí 'Success to copy text!'
  - Ïã§Ìå® Ïãú: Ko/Eng Í∞ÅÍ∞Å ÏóêÎü¨ ÌÜ†Ïä§Ìä∏

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
5) getHighlightedFragments(text, items, focusIndex, map, classes?)
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
- Í∏∞Îä•: Î≤îÏúÑ Ï†ïÎ≥¥(offset, length)Î•º Í∞ÄÏßÑ Ìï≠Î™© Î∞∞Ïó¥ÏùÑ Î∞õÏïÑ, ÏõêÎ¨∏ Î¨∏ÏûêÏó¥ÏùÑ ReactNode[]Î°ú Î∂ÑÌï¥ÌïòÏó¨ Í∞Ä-highlightÎêú Ï°∞Í∞ÅÎì§ÏùÑ Î∞òÌôò.
- ÏûÖÎ†•:
  - text: ÏõêÎ¨∏ Î¨∏ÏûêÏó¥
  - items: Îß§Ìïë ÎåÄÏÉÅ Î∞∞Ïó¥(T[])
  - focusIndex: Ìè¨Ïª§Ïä§Ìï† highlight Ïù∏Îç±Ïä§(ÍµµÍ≤å/Í∞ïÏ°∞)
  - map: (item: T) => { offset: number; length: number; tooltip?: string }
  - classes?: { base?: string; focus?: string }
- Ï∂úÎ†•: React.ReactNode[]
- ÎèôÏûë:
  - itemsÎ•º map ‚Üí {offset, length, tooltip}Î°ú Ï†ïÍ∑úÌôî ÌõÑ, Ïò§ÌîÑÏÖã ÏàúÏúºÎ°ú ÏÜåÌåÖ
  - ÎπÑÌïòÏù¥ÎùºÏù¥Ìä∏ Íµ¨Í∞ÑÏùÄ ÏùºÎ∞ò ÌÖçÏä§Ìä∏, ÌïòÏù¥ÎùºÏù¥Ìä∏ Íµ¨Í∞ÑÏùÄ <mark>Î°ú Í∞êÏã∏ÏÑú Î∞òÌôò
  - focusIndexÎäî Î≥ÑÎèÑ ÌÅ¥ÎûòÏä§(focus) Ï†ÅÏö©
- Í∏∞Î≥∏ ÌÅ¥ÎûòÏä§:
  - base: 'rounded bg-red-200 px-0.5 text-red-800 underline decoration-red-400 decoration-2'
  - focus: 'rounded bg-red-300 px-0.5 font-bold text-red-900 underline decoration-red-600 decoration-2'
- Ï£ºÏùò:
  - Ïò§ÌîÑÏÖã ÌÅ¥Îû®ÌîÑ Ï≤òÎ¶¨(Î¨∏ÏûêÏó¥ Î≤îÏúÑ Ï¥àÍ≥º Î∞©ÏßÄ)
  - Í≤πÏπòÎäî ÏòÅÏó≠Ïù¥ ÏûàÏùÑ Í≤ΩÏö∞, Ï†ÑÎã¨ ÏàúÏÑú Í∏∞Ï§ÄÏúºÎ°ú Ï≤òÎ¶¨Îê®

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
6) mapLanguageToolMatch(match)
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
- Í∏∞Îä•: LanguageToolÏùò MatchÎ•º getHighlightedFragmentsÏö© {offset, length, tooltip} ÌòïÌÉúÎ°ú Îß§Ìïë.
- ÏûÖÎ†•: match: Match({ offset, length, message, ... })
- Ï∂úÎ†•: { offset, length, tooltip }

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
7) mapKoChange(change)
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
- Í∏∞Îä•: ÌïúÍµ≠Ïñ¥ ÍµêÏ†ï Í≤∞Í≥º(ÏÇΩÏûÖ/ÏÇ≠Ï†ú/ÏπòÌôò)Î•º ÌïòÏù¥ÎùºÏù¥Ìä∏Ïö© Íµ¨Ï°∞Î°ú Îß§Ìïë.
- ÏûÖÎ†•: change: KoChange({ from, to, offset, length, ... })
- Ï∂úÎ†•: { offset, length, tooltip }
  - tooltip Ïòà: INSERT/DELETE/REPLACE ‚Äî "from" ‚Üí "to"
- ÌåêÎ≥Ñ:
  - !from && to ‚Üí INSERT
  - from && !to ‚Üí DELETE
  - Í∑∏ Ïô∏ ‚Üí REPLACE
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
8) handlePasteImageUrl(e)
 ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
- Í∏∞Îä•: Î∂ôÏó¨ÎÑ£Í∏∞ Ïù¥Î≤§Ìä∏ÏóêÏÑú Ïù¥ÎØ∏ÏßÄ URLÏùÑ Í∞êÏßÄÌïòÏó¨ HTML <img> ÌÉúÍ∑∏ ÎòêÎäî ÎßàÌÅ¨Îã§Ïö¥ ![]() Î¨∏Î≤ïÏúºÎ°ú ÏÇΩÏûÖ.
- ÏûÖÎ†•: e: React.ClipboardEvent<HTMLTextAreaElement> ‚Üí textareaÏóêÏÑú Î∞úÏÉùÌïú paste Ïù¥Î≤§Ìä∏ Í∞ùÏ≤¥.
- Ï∂úÎ†•:
  - boolean ‚Üí true: Ïù¥ÎØ∏ÏßÄ URL Í∞êÏßÄ Î∞è ÏÇΩÏûÖ ÏôÑÎ£å, false: Í∏∞Î≥∏ Î∂ôÏó¨ÎÑ£Í∏∞ ÎèôÏûë ÏßÑÌñâ.
- ÎπÑÍ≥†:
  - http(s)Î°ú ÏãúÏûëÌïòÍ≥† png/jpg/jpeg/gif/webp/svg ÌôïÏû•ÏûêÎ°ú ÎÅùÎÇòÎäî URL(ÏøºÎ¶¨Ïä§Ìä∏ÎßÅ ÌóàÏö©)ÏùÑ Í∞êÏßÄ.
  - confirm Ï∞ΩÏóêÏÑú ÏÑ†ÌÉù:
    - ÌôïÏù∏(OK): HTML <img src="..."> ÌòïÌÉúÎ°ú ÏÇΩÏûÖ.
    - Ï∑®ÏÜå(Cancel): ÎßàÌÅ¨Îã§Ïö¥ ![image](...) ÌòïÌÉúÎ°ú ÏÇΩÏûÖ.
  - URLÏù¥ Í∞êÏßÄÎêòÎ©¥ Í∏∞Î≥∏ Î∂ôÏó¨ÎÑ£Í∏∞ ÎèôÏûëÏùÑ ÎßâÏùå.
*/
